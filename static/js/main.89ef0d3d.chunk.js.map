{"version":3,"sources":["features/game/Game.module.css","app/hooks.ts","features/game/Position.ts","features/search/Brain.ts","features/game/gameSlice.ts","features/game/GridCell.tsx","features/game/Game.tsx","App.tsx","features/counter/counterAPI.ts","features/counter/counterSlice.ts","app/store.ts","serviceWorker.ts","index.tsx"],"names":["module","exports","useAppDispatch","useDispatch","useSelector","posEquals","pos1","pos2","x","y","posHash","pos","head","unit","positions","length","inBounds","width","height","filter","empty","units","overlapsAnything","unseen","seenPos","otherPos","withinRange","position","distance","adjacentPositions","Math","abs","push","initialState","turn","phase","gridSize","movesUsed","attackUsed","stats","name","maxLength","range","movement","attack","color","headColor","id","reduce","map","newPosition","overlaps","existingPosition","unitAt","gameSlice","createSlice","reducers","move","state","action","undefined","selectedUnit","oldPositions","oldHead","locationValid","getUnitList","payload","shift","select","reset","targetPosition","target","attacker","attackerHead","isInRange","splice","endTurn","actions","getSelectedUnit","Object","values","getGridGlows","createSelector","gridGlows","forEach","getGridColors","gridColors","mover","initialNode","queue","curNode","nodeOrUndef","nearPlaces","inPlaces","emptyPlaces","unseenPlaces","newNode","bfs","GridCell","glowColor","dispatch","game","handleClick","event","button","isEmpty","preventDefault","style","backgroundColor","boxShadow","onContextMenu","onClick","grid","Array","keys","i","cellPos","floor","positionOfGrid","Game","Fragment","className","styles","wrapper","App","fetchCount","amount","Promise","resolve","setTimeout","data","incrementAsync","createAsyncThunk","a","response","counterSlice","value","status","increment","decrement","incrementByAmount","extraReducers","builder","addCase","pending","fulfilled","store","configureStore","reducer","counter","counterReducer","gameReducer","Boolean","window","location","hostname","match","ReactDOM","render","StrictMode","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister","catch","error","console","message"],"mappings":"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","file":"static/js/main.89ef0d3d.chunk.js","sourcesContent":["// extracted by mini-css-extract-plugin\nmodule.exports = {\"wrapper\":\"Game_wrapper__3oH14\",\"selected\":\"Game_selected__7QQur\"};","import { TypedUseSelectorHook, useDispatch, useSelector } from 'react-redux';\nimport type { RootState, AppDispatch } from './store';\n\n// Use throughout your app instead of plain `useDispatch` and `useSelector`\nexport const useAppDispatch = () => useDispatch<AppDispatch>();\nexport const useAppSelector: TypedUseSelectorHook<RootState> = useSelector;\n","export interface Position {\n    x: number;\n    y: number;\n}\n\nexport const posEquals=(pos1:Position,pos2:Position)=>{\n  return pos1.x===pos2.x && pos1.y===pos2.y;\n}\n\nexport const posHash = (pos: Position) =>{\n  return pos.x+\"-\"+pos.y;\n}\n","import Unit from \"../unit/Unit\";\nimport { Position, posEquals } from \"../game/Position\";\nimport { overlapsAnything } from \"../game/gameSlice\";\n\n\nexport const head = (unit: Unit) => {\n  return unit.positions[unit.positions.length - 1];\n}\n\nexport const isInRange = (attacker: Unit, target: Position) => {\n  const attackerHead = head(attacker);\n  return Math.abs(attackerHead.x - target.x) + Math.abs(attackerHead.y - target.y) <= attacker.stats.range;\n}\n\nexport const withinAttackRange = (attacker: Unit) => {\n  return withinRange(head(attacker), attacker.stats.range);\n}\n\nconst inBounds = (positions: Position[], width: number, height: number) => {\n  return positions.filter(pos => pos.x >= 0 && pos.x < width && pos.y >= 0 && pos.y < height);\n}\n\nconst empty = (positions: Position[], units: Unit[]) => {\n  return positions.filter(pos => !overlapsAnything(units, pos));\n}\n\nconst unseen = (positions: Position[], seenPos: Position[]) => {\n  return positions.filter(pos => {\n    //TODO: Eww, replace with set and hash/equals implementation\n    for (const otherPos of seenPos) {\n      if (posEquals(pos, otherPos)) {\n        return false;\n      }\n    }\n    return true;\n  })\n}\n\nconst withinRange = (position: Position, distance: number) => {\n  const adjacentPositions = [];\n  for (let x = -distance; x <= distance; x++) {\n    for (let y = -distance + Math.abs(x); y <= distance - Math.abs(x); y++) {\n      adjacentPositions.push({\n        x: position.x + x,\n        y: position.y + y\n      });\n    }\n  }\n  return adjacentPositions;\n}\n\nconst adjacent = (position: Position) => withinRange(position, 1);\n\nexport const bfs = (mover: Unit, units: Unit[], gridSize: { width: number, height: number }) => {\n  if (mover.attackUsed) {\n    return [];\n  }\n  const initialNode = {\n    position: head(mover),\n    movement: mover.stats.movement - mover.movesUsed,\n  }\n  const { width, height } = gridSize;\n\n  const queue = [initialNode];\n  const seenPos: Position[] = [];\n\n  let curNode = initialNode;\n  while (queue.length !== 0) {\n    const nodeOrUndef = queue.shift();\n    if (nodeOrUndef === undefined) {\n      return []; //Lets please the tyrannical typescript gods\n    } else {\n      curNode = nodeOrUndef;\n    }\n\n    if (!posEquals(curNode.position, head(mover))) {\n      seenPos.push(curNode.position);\n    }\n\n    if (curNode.movement === 0) {\n      continue; //Stop right there, yall aint got none movement\n    }\n\n    const nearPlaces = adjacent(curNode.position);\n    const inPlaces = inBounds(nearPlaces, width, height);\n    const emptyPlaces = empty(inPlaces, units);\n    const unseenPlaces = unseen(emptyPlaces, seenPos);\n\n    for (const validPlace of unseenPlaces) {\n      const newNode = {\n        position: validPlace,\n        movement: curNode.movement - 1,\n      }\n      queue.push(newNode);\n    }\n  }\n  return seenPos;\n}\n","import { createSelector, createSlice, PayloadAction } from \"@reduxjs/toolkit\";\nimport Unit from \"../unit/Unit\";\nimport { Position, posHash } from \"./Position\";\nimport { bfs, head, isInRange, withinAttackRange } from \"../search/Brain\";\n\nconst SELECTED_COLOR = \"#384bfa\";\nconst VALID_MOVE_POSITION_COLOR = \"rgb(200, 206, 255)\";\nconst VALID_ATTACK_POSITION_COLOR = \"#ff0000\";\n\nexport interface GameState {\n    turn: number;\n    units: { [key: string]: Unit };\n    selectedUnit?: string;\n    phase: \"action\";\n    gridSize: { width: number, height: number };\n};\n\nconst defaultUnits: Unit[] = [{\n    positions: [{ x: 0, y: 0 }],\n    movesUsed: 0,\n    attackUsed: false,\n    stats: {\n        name: \"Red\",\n        maxLength: 5,\n        range: 1,\n        movement: 2,\n        attack: 3,\n        color: \"red\",\n        headColor: \"brown\",\n        id: \"a\",\n    }\n},\n{\n    positions: [{ x: 4, y: 4 }],\n    movesUsed: 0,\n    attackUsed: false,\n    stats: {\n        name: \"Yellow\",\n        maxLength: 2,\n        range: 3,\n        movement: 1,\n        attack: 1,\n        color: \"yellow\",\n        headColor: \"rgb(228, 208, 34)\",\n        id: \"b\",\n    }\n},\n{\n    positions: [{ x: 9, y: 9 }],\n    movesUsed: 0,\n    attackUsed: false,\n    stats: {\n        name: \"Purple\",\n        maxLength: 1,\n        range: 1,\n        movement: 5,\n        attack: 2,\n        color: \"purple\",\n        headColor: \"pink\",\n        id: \"p\",\n    }\n}];\n\nexport const positionOfGrid = (i: number, gridSize: { height: number, width: number }) => {\n    const x = Math.floor(i / gridSize.width);\n    const y = i % gridSize.height;\n    return { x, y };\n}\n\nexport const isSelected = (position: Position, selectedUnit: Unit | undefined) => {\n    if (!selectedUnit) {\n        return false;\n    }\n    return selectedUnit.positions.some(\n        unitPosition => unitPosition.x === position.x && unitPosition.y === position.y\n    );\n}\n\n/**\n  Returns a map of {PosHashStr:glowColorStr}\n*/\nexport const generateGridGlows = (selectedUnit: Unit | undefined) => {\n    const gridGlows: { [key: string]: string } = {};\n    if (!selectedUnit) {\n        return gridGlows;\n    }\n    withinAttackRange(selectedUnit).forEach(position => {\n        gridGlows[posHash(position)] = VALID_ATTACK_POSITION_COLOR;\n    });\n    selectedUnit.positions.forEach(position => {\n        gridGlows[posHash(position)] = SELECTED_COLOR;\n    });\n    return gridGlows;\n}\n\nexport const generateGridColors = (\n    selectedUnit: Unit | undefined,\n    units: Unit[],\n    gridSize: { height: number, width: number },\n) => {\n    const gridColors: { [key: string]: string } = {};\n    units.forEach(unit => {\n        unit.positions.forEach(position => {\n            gridColors[posHash(position)] = unit.stats.color;\n        });\n        gridColors[posHash(head(unit))] = unit.stats.headColor;\n    });\n    if (selectedUnit) {\n        const validMovePositions = bfs(selectedUnit, units, gridSize);\n        validMovePositions.forEach(position => {\n            gridColors[posHash(position)] = VALID_MOVE_POSITION_COLOR;\n        });\n    }\n    return gridColors;\n}\n\nconst initialGridSize = { width: 10, height: 10 };\nconst initialUnits = defaultUnits.reduce((map: { [key: string]: Unit }, unit) => {\n    map[unit.stats.id] = unit;\n    return map;\n}, {});\nconst initialState: GameState = {\n    turn: 0,\n    phase: \"action\",\n    gridSize: initialGridSize,\n    units: initialUnits,\n};\n\nexport const overlapsAnything = (units: Unit[], newPosition: Position) => {\n    for (const unit of units) {\n        if (overlaps(unit.positions, newPosition)) {\n            return true;\n        }\n    }\n    return false;\n}\n\nconst overlaps = (positions: Position[], position: Position) => {\n    for (const existingPosition of positions) {\n        if (existingPosition.x === position.x && existingPosition.y === position.y) {\n            return true;\n        }\n    }\n    return false;\n}\n\nconst locationValid = (units: Unit[], unit: Unit, newPosition: Position) => {\n    const oldPositions = unit.positions;\n    const oldHead = oldPositions[oldPositions.length - 1];\n    return Math.abs(newPosition.x - oldHead.x) +\n        Math.abs(newPosition.y - oldHead.y) <= 1 &&\n        !overlapsAnything(units, newPosition);\n}\n\nexport const unitAt = (position: Position, units: Unit[]) => {\n    for (const unit of units) {\n        if (overlaps(unit.positions, position)) {\n            return unit;\n        }\n    }\n}\n\nexport const gameSlice = createSlice({\n    name: 'game',\n    initialState,\n    reducers: {\n        move: (state: GameState, action: PayloadAction<Position>) => {\n            if (state.phase !== \"action\" || state.selectedUnit === undefined) {\n                return;\n            }\n            const unit = state.units[state.selectedUnit];\n            if (unit.movesUsed >= unit.stats.movement) {\n                return;\n            }\n            const units = getUnitList(state);\n            if (locationValid(units, unit, action.payload)) {\n                unit.positions.push(action.payload);\n                unit.movesUsed++;\n            }\n            if (unit.positions.length > unit.stats.maxLength) {\n                unit.positions.shift();\n            }\n        },\n        select: (state: GameState, action: PayloadAction<Position>) => {\n            const units = getUnitList(state);\n            const selectedUnit = unitAt(action.payload, units);\n            if (selectedUnit) {\n                state.phase = \"action\";\n                state.selectedUnit = selectedUnit.stats.id;\n            }\n        },\n        reset: () => {\n            return initialState;\n        },\n        attack: (state: GameState, action: PayloadAction<Position>) => {\n            const targetPosition = action.payload;\n            const units = getUnitList(state);\n            const target = unitAt(targetPosition, units);\n            if (state.phase !== \"action\" || state.selectedUnit === undefined || !target) {\n                return;\n            }\n            const unit = state.units[state.selectedUnit];\n            if (unit === target || unit.attackUsed || !isInRange(unit, targetPosition)) {\n                return;\n            }\n            unit.attackUsed = true;\n            if (unit.stats.attack >= target.positions.length) {\n                delete state.units[target.stats.id];\n            }\n            target.positions.splice(0, unit.stats.attack);\n        },\n        endTurn: (state: GameState) => {\n            state.turn++;\n            for (const unit of getUnitList(state)) {\n                unit.movesUsed = 0;\n                unit.attackUsed = false;\n            };\n        },\n    },\n});\n\nexport const { move, select, attack, reset, endTurn } = gameSlice.actions;\n\nexport const getSelectedUnit = (state: GameState) =>\n    state.selectedUnit ? state.units[state.selectedUnit] : undefined;\n\nexport const getUnitList = (state: GameState) => Object.values(state.units);\n\nexport const getGridGlows = createSelector(getSelectedUnit, getUnitList, state => state.gridSize, generateGridGlows);\nexport const getGridColors = createSelector(getSelectedUnit, getUnitList, state => state.gridSize, generateGridColors);\n\nexport default gameSlice.reducer;\n","import { attack, move, select, unitAt, getUnitList } from \"./gameSlice\";\nimport { useAppDispatch } from \"../../app/hooks\";\nimport { Position } from \"./Position\";\nimport { useSelector } from \"react-redux\";\nimport { RootState } from \"../../app/store\";\nimport Unit from \"../unit/Unit\";\n\n\ntype Props = {\n    position: Position,\n    color?: string,\n    glowColor?: string,\n};\n\nconst isEmpty = (position: Position, units: Unit[]) => unitAt(position, units) === undefined;\n\nexport const GridCell = ({ position, color, glowColor }: Props) => {\n    const dispatch = useAppDispatch();\n    const units = useSelector((state: RootState) => getUnitList(state.game));\n    const handleClick = (event: React.MouseEvent<HTMLDivElement, MouseEvent>) => {\n        switch (event.button) {\n            case 0:\n                if (isEmpty(position, units)) {\n                    dispatch(move(position)); break;\n                } else {\n                    dispatch(select(position)); break;\n                }\n            case 2:\n                dispatch(attack(position));\n                event.preventDefault();\n                break;\n\n        };\n    }\n    const style = {\n        backgroundColor: color,\n        boxShadow: glowColor ? \"0px 0px 10px\" + glowColor : undefined,\n    };\n    return <div\n        style={style}\n        onContextMenu={handleClick}\n        onClick={handleClick}\n    ></div>;\n}\n","import React from \"react\";\nimport { useSelector } from \"react-redux\"\nimport { useAppDispatch } from \"../../app/hooks\";\nimport { RootState } from \"../../app/store\";\nimport styles from './Game.module.css';\nimport { endTurn, reset, getSelectedUnit, positionOfGrid, getGridGlows, getGridColors } from \"./gameSlice\";\nimport { GridCell } from \"./GridCell\";\nimport { posHash } from \"./Position\";\n\nconst grid = (\n    gridSize: { height: number, width: number },\n    gridGlows: { [key: string]: string | undefined },\n    gridColors: { [key: string]: string | undefined },\n) => [...Array(gridSize.height * gridSize.width).keys()]\n    .map(i => {\n        const cellPos = positionOfGrid(i, gridSize);\n        const glowColor = gridGlows[posHash(cellPos)];\n        const color = gridColors[posHash(cellPos)];\n        return <GridCell\n            key={i}\n            color={color}\n            glowColor={glowColor}\n            position={cellPos} />\n    });\n\nexport function Game() {\n    const dispatch = useAppDispatch();\n    const { gridSize, phase, selectedUnit, turn, gridGlows, gridColors } =\n        useSelector((state: RootState) => ({\n            ...state.game,\n            selectedUnit: getSelectedUnit(state.game),\n            gridGlows: getGridGlows(state.game),\n            gridColors: getGridColors(state.game),\n        }));\n    return (\n        <React.Fragment>\n            <p>Turn {turn + 1}</p> <button onClick={() => dispatch(endTurn())}>End Turn</button>\n            <p>{phase}{selectedUnit !== undefined ? \": \" + selectedUnit.stats.name : \"\"}</p>\n            <div className={styles.wrapper}>\n                {grid(gridSize, gridGlows, gridColors)}\n            </div>\n            <button onClick={() => dispatch(reset())}>reset</button>\n        </React.Fragment>\n    );\n}\n","import './App.css';\nimport { Game } from './features/game/Game';\n\nfunction App() {\n  return <Game />;\n}\n\nexport default App;\n","// A mock function to mimic making an async request for data\nexport function fetchCount(amount = 1) {\n  return new Promise<{ data: number }>((resolve) =>\n    setTimeout(() => resolve({ data: amount }), 500)\n  );\n}\n","import { createAsyncThunk, createSlice, PayloadAction } from '@reduxjs/toolkit';\nimport { RootState, AppThunk } from '../../app/store';\nimport { fetchCount } from './counterAPI';\n\nexport interface CounterState {\n  value: number;\n  status: 'idle' | 'loading' | 'failed';\n}\n\nconst initialState: CounterState = {\n  value: 0,\n  status: 'idle',\n};\n\n// The function below is called a thunk and allows us to perform async logic. It\n// can be dispatched like a regular action: `dispatch(incrementAsync(10))`. This\n// will call the thunk with the `dispatch` function as the first argument. Async\n// code can then be executed and other actions can be dispatched. Thunks are\n// typically used to make async requests.\nexport const incrementAsync = createAsyncThunk(\n  'counter/fetchCount',\n  async (amount: number) => {\n    const response = await fetchCount(amount);\n    // The value we return becomes the `fulfilled` action payload\n    return response.data;\n  }\n);\n\nexport const counterSlice = createSlice({\n  name: 'counter',\n  initialState,\n  // The `reducers` field lets us define reducers and generate associated actions\n  reducers: {\n    increment: (state) => {\n      // Redux Toolkit allows us to write \"mutating\" logic in reducers. It\n      // doesn't actually mutate the state because it uses the Immer library,\n      // which detects changes to a \"draft state\" and produces a brand new\n      // immutable state based off those changes\n      state.value += 1;\n    },\n    decrement: (state) => {\n      state.value -= 1;\n    },\n    // Use the PayloadAction type to declare the contents of `action.payload`\n    incrementByAmount: (state, action: PayloadAction<number>) => {\n      state.value += action.payload;\n    },\n  },\n  // The `extraReducers` field lets the slice handle actions defined elsewhere,\n  // including actions generated by createAsyncThunk or in other slices.\n  extraReducers: (builder) => {\n    builder\n      .addCase(incrementAsync.pending, (state) => {\n        state.status = 'loading';\n      })\n      .addCase(incrementAsync.fulfilled, (state, action) => {\n        state.status = 'idle';\n        state.value += action.payload;\n      });\n  },\n});\n\nexport const { increment, decrement, incrementByAmount } = counterSlice.actions;\n\n// The function below is called a selector and allows us to select a value from\n// the state. Selectors can also be defined inline where they're used instead of\n// in the slice file. For example: `useSelector((state: RootState) => state.counter.value)`\nexport const selectCount = (state: RootState) => state.counter.value;\n\n// We can also write thunks by hand, which may contain both sync and async logic.\n// Here's an example of conditionally dispatching actions based on current state.\nexport const incrementIfOdd = (amount: number): AppThunk => (\n  dispatch,\n  getState\n) => {\n  const currentValue = selectCount(getState());\n  if (currentValue % 2 === 1) {\n    dispatch(incrementByAmount(amount));\n  }\n};\n\nexport default counterSlice.reducer;\n","import { configureStore, ThunkAction, Action } from '@reduxjs/toolkit';\nimport counterReducer from '../features/counter/counterSlice';\nimport gameReducer from '../features/game/gameSlice';\n\nexport const store = configureStore({\n  reducer: {\n    counter: counterReducer,\n    game: gameReducer,\n  },\n});\n\nexport type AppDispatch = typeof store.dispatch;\nexport type RootState = ReturnType<typeof store.getState>;\nexport type AppThunk<ReturnType = void> = ThunkAction<\n  ReturnType,\n  RootState,\n  unknown,\n  Action<string>\n>;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then((registration) => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch((error) => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' },\n  })\n    .then((response) => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then((registration) => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then((registration) => {\n        registration.unregister();\n      })\n      .catch((error) => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport { store } from './app/store';\nimport { Provider } from 'react-redux';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(\n  <React.StrictMode>\n    <Provider store={store}>\n      <App />\n    </Provider>\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}