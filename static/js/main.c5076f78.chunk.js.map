{"version":3,"sources":["features/game/Game.module.css","app/hooks.ts","features/game/Position.ts","features/game/Grid.ts","features/search/Brain.ts","features/game/gameSlice.ts","features/game/GridCell.tsx","features/game/UnitInfo.tsx","features/game/Game.tsx","App.tsx","features/counter/counterAPI.ts","features/counter/counterSlice.ts","app/store.ts","serviceWorker.ts","index.tsx"],"names":["module","exports","useAppDispatch","useDispatch","useSelector","posEquals","pos1","pos2","x","y","posHash","pos","revHash","posStr","posList","split","parseInt","gridDimensions","grid","maxX","maxY","Object","keys","key","width","height","inGrid","hasOwnProperty","head","unit","positions","length","inBounds","filter","empty","units","overlapsAnything","unseen","seenPos","otherPos","withinRange","position","distance","adjacentPositions","Math","abs","push","unitColor","hue","d3","toString","unitHeadColor","UNIT_SATURATION","UNIT_LIGHTNESS","defaultUnits","movesUsed","attackUsed","stats","name","maxLength","range","movement","attack","color","headColor","id","initialGrid","toReturn","i","j","rectGridConstructor","initialState","turn","phase","reduce","map","selectedUnit","players","unitIds","newPosition","overlaps","existingPosition","unitAt","gameSlice","createSlice","reducers","move","state","action","undefined","getUnitList","oldPositions","oldHead","locationValid","payload","shift","select","activeUnits","getActivePlayerUnits","reset","targetPosition","enemyUnits","getEnemyUnits","target","attacker","attackerHead","isInRange","deleteDeadPlayers","winner","splice","endTurn","clickMove","getSelectedUnit","clickAttack","actions","values","getUnitsForPlayer","getActivePlayer","player","unitId","activeUnitIds","includes","selectUnitList","game","selectActivePlayerUnits","selectActivePlayer","selectSelectedUnit","getGridGlows","createSelector","gridGlows","forEach","getGridColors","activePlayer","gridColors","entries","isActivePlayerUnit","s","l","mover","initialNode","queue","curNode","nodeOrUndef","nearPlaces","inPlaces","emptyPlaces","unseenPlaces","newNode","bfs","GridCell","glowColor","dispatch","activePlayerUnits","style","backgroundColor","boxShadow","transition","onClick","isEmpty","UnitInfo","className","styles","unitInfo","genGrid","Array","cellPos","gridSize","floor","positionOfGrid","Game","Fragment","button","disabled","mapAndInfo","wrapper","App","fetchCount","amount","Promise","resolve","setTimeout","data","incrementAsync","createAsyncThunk","a","response","counterSlice","value","status","increment","decrement","incrementByAmount","extraReducers","builder","addCase","pending","fulfilled","store","configureStore","reducer","counter","counterReducer","gameReducer","Boolean","window","location","hostname","match","ReactDOM","render","StrictMode","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister","catch","error","console","message"],"mappings":"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","file":"static/js/main.c5076f78.chunk.js","sourcesContent":["// extracted by mini-css-extract-plugin\nmodule.exports = {\"wrapper\":\"Game_wrapper__3oH14\",\"selected\":\"Game_selected__7QQur\",\"unitInfo\":\"Game_unitInfo__1r61w\",\"mapAndInfo\":\"Game_mapAndInfo__2_8Qy\",\"button\":\"Game_button__P34Uo\"};","import { TypedUseSelectorHook, useDispatch, useSelector } from 'react-redux';\nimport type { RootState, AppDispatch } from './store';\n\n// Use throughout your app instead of plain `useDispatch` and `useSelector`\nexport const useAppDispatch = () => useDispatch<AppDispatch>();\nexport const useAppSelector: TypedUseSelectorHook<RootState> = useSelector;\n","export interface Position {\n    x: number;\n    y: number;\n}\n\nexport const posEquals=(pos1:Position,pos2:Position)=>{\n  return pos1.x===pos2.x && pos1.y===pos2.y;\n}\n\nexport const posHash = (pos: Position) =>{\n  return pos.x+\"-\"+pos.y;\n}\n\nexport const revHash = (posStr:string) =>{\n  const posList=posStr.split(\"-\");\n  return {x:parseInt(posList[0]), y:parseInt(posList[1])};\n} \n","import { Position, revHash } from \"./Position\";\nimport { posHash } from \"./Position\";\n\nexport type Grid =  {\n    [key: string]:boolean\n};\n\nexport const gridDimensions = (grid: Grid) =>{\n    let maxX=-1000;\n    let maxY=-1000;\n    for(let key of Object.keys(grid)){\n        const {x,y}=revHash(key);\n        if (x>maxX){\n            maxX=x;\n        }\n        if(y>maxY){\n            maxY=y;\n        }\n    }\n    return {width:maxX+1,height:maxY+1};\n}\n\nexport const positionOfGrid = (i: number, grid:Grid) => {\n    const gridSize=gridDimensions(grid);\n    const x = Math.floor(i / gridSize.width);\n    const y = i % gridSize.height;\n    return { x, y };\n}\n\nexport const inGrid = (grid:Grid, pos: Position) =>{\n    return grid.hasOwnProperty(posHash(pos)) && grid[posHash(pos)]===true;\n}\n\nexport const rectGridConstructor = (width:number, height:number) => {\n    const toReturn : Grid ={};\n    for(let i=0; i<width; i+=1){\n        for(let j=0; j<height; j+=1){\n            toReturn[posHash({x:i,y:j})]=true;\n        }\n    }\n    return toReturn;\n}","import Unit from \"../unit/Unit\";\nimport { Position, posEquals } from \"../game/Position\";\nimport { overlapsAnything } from \"../game/gameSlice\";\nimport { Grid, inGrid } from \"../game/Grid\";\n\n\nexport const head = (unit: Unit) => {\n  return unit.positions[unit.positions.length - 1];\n}\n\nexport const isInRange = (attacker: Unit, target: Position) => {\n  const attackerHead = head(attacker);\n  return Math.abs(attackerHead.x - target.x) + Math.abs(attackerHead.y - target.y) <= attacker.stats.range;\n}\n\nexport const withinAttackRange = (attacker: Unit) => {\n  return withinRange(head(attacker), attacker.stats.range);\n}\n\nconst inBounds = (positions: Position[], grid: Grid) => {\n  return positions.filter(pos => inGrid(grid, pos));\n}\n\nconst empty = (positions: Position[], units: Unit[]) => {\n  return positions.filter(pos => !overlapsAnything(units, pos));\n}\n\nconst unseen = (positions: Position[], seenPos: Position[]) => {\n  return positions.filter(pos => {\n    //TODO: Eww, replace with set and hash/equals implementation\n    for (const otherPos of seenPos) {\n      if (posEquals(pos, otherPos)) {\n        return false;\n      }\n    }\n    return true;\n  })\n}\n\nconst withinRange = (position: Position, distance: number) => {\n  const adjacentPositions = [];\n  for (let x = -distance; x <= distance; x++) {\n    for (let y = -distance + Math.abs(x); y <= distance - Math.abs(x); y++) {\n      adjacentPositions.push({\n        x: position.x + x,\n        y: position.y + y\n      });\n    }\n  }\n  return adjacentPositions;\n}\n\nconst adjacent = (position: Position) => withinRange(position, 1);\n\nexport const bfs = (mover: Unit, units: Unit[], grid: Grid) => {\n  const initialNode = {\n    position: head(mover),\n    movement: mover.stats.movement - mover.movesUsed,\n  }\n  const queue = [initialNode];\n  const seenPos: Position[] = [];\n\n  let curNode = initialNode;\n  while (queue.length !== 0) {\n    const nodeOrUndef = queue.shift();\n    if (nodeOrUndef === undefined) {\n      return []; //Lets please the tyrannical typescript gods\n    } else {\n      curNode = nodeOrUndef;\n    }\n\n    if (!posEquals(curNode.position, head(mover))) {\n      seenPos.push(curNode.position);\n    }\n\n    if (curNode.movement === 0) {\n      continue; //Stop right there, yall aint got none movement\n    }\n\n    const nearPlaces = adjacent(curNode.position);\n    const inPlaces = inBounds(nearPlaces, grid);\n    const emptyPlaces = empty(inPlaces, units);\n    const unseenPlaces = unseen(emptyPlaces, seenPos);\n\n    for (const validPlace of unseenPlaces) {\n      const newNode = {\n        position: validPlace,\n        movement: curNode.movement - 1,\n      }\n      queue.push(newNode);\n    }\n  }\n  return seenPos;\n}\n","import { createSelector, createSlice, PayloadAction } from \"@reduxjs/toolkit\";\nimport Unit from \"../unit/Unit\";\nimport { Position, posHash } from \"./Position\";\nimport { bfs, head, isInRange, withinAttackRange } from \"../search/Brain\";\nimport { Grid, inGrid, rectGridConstructor } from \"./Grid\";\nimport * as d3 from \"d3-color\";\nimport { RootState } from \"../../app/store\";\n\n\nconst SELECTED_COLOR = \"#384bfa\";\nconst VALID_MOVE_POSITION_COLOR = \"rgb(201, 230, 253)\";\nconst VALID_ATTACK_POSITION_COLOR = \"#ff0000\";\nconst GAP_COLOR = \"#ffffff\";\n\nconst UNIT_LIGHTNESS = 0.6; // 0 to 1\nconst UNIT_SATURATION = 1; // 0 to 2\n\nconst unitColor = (hue: number) => {\n    return d3.cubehelix(hue, UNIT_SATURATION, UNIT_LIGHTNESS).toString();\n}\n\nconst unitHeadColor = (hue: number) => {\n    return d3.cubehelix(hue, UNIT_SATURATION + 0.2, UNIT_LIGHTNESS - 0.3).toString();\n}\n\nexport type Player = {\n    name: string;\n    unitIds: string[];\n}\n\nexport type Phase = \"move\" | \"attack\" | \"game over\";\n\nexport interface GameState {\n    turn: number;\n    units: { [key: string]: Unit };\n    selectedUnit?: string;\n    grid: Grid;\n    winner?: string;\n    phase: Phase;\n    players: Player[];\n};\n\nconst defaultUnits: Unit[] = [{\n    positions: [{ x: 0, y: 0 }],\n    movesUsed: 0,\n    attackUsed: false,\n    stats: {\n        name: \"Heavy hitter\",\n        maxLength: 5,\n        range: 1,\n        movement: 2,\n        attack: 3,\n        color: unitColor(0),\n        headColor: unitHeadColor(0),\n        id: \"a\",\n    }\n},\n{\n    positions: [{ x: 4, y: 4 }],\n    movesUsed: 0,\n    attackUsed: false,\n    stats: {\n        name: \"Ranged and slow\",\n        maxLength: 2,\n        range: 3,\n        movement: 1,\n        attack: 1,\n        color: unitColor(100),\n        headColor: unitHeadColor(100),\n        id: \"b\",\n    }\n},\n{\n    positions: [{ x: 9, y: 9 }],\n    movesUsed: 0,\n    attackUsed: false,\n    stats: {\n        name: \"Glass cannon\",\n        maxLength: 1,\n        range: 1,\n        movement: 5,\n        attack: 2,\n        color: unitColor(200),\n        headColor: unitHeadColor(200),\n        id: \"c\",\n    }\n}];\n\nexport const isSelected = (position: Position, selectedUnit: Unit | undefined) => {\n    if (!selectedUnit) {\n        return false;\n    }\n    return selectedUnit.positions.some(\n        unitPosition => unitPosition.x === position.x && unitPosition.y === position.y\n    );\n}\n\n/**\n  Returns a map of {PosHashStr:glowColorStr}\n*/\nexport const generateGridGlows = (selectedUnit: Unit | undefined, phase: Phase) => {\n    const gridGlows: { [key: string]: string } = {};\n    if (!selectedUnit) {\n        return gridGlows;\n    }\n    if (phase === \"attack\" && !selectedUnit.attackUsed) {\n        withinAttackRange(selectedUnit).forEach(position => {\n            gridGlows[posHash(position)] = VALID_ATTACK_POSITION_COLOR;\n        });\n    }\n    selectedUnit.positions.forEach(position => {\n        gridGlows[posHash(position)] = SELECTED_COLOR;\n    });\n    return gridGlows;\n}\n\nexport const generateGridColors = (\n    selectedUnit: Unit | undefined,\n    phase: Phase,\n    units: Unit[],\n    grid: Grid,\n    activePlayer: Player,\n) => {\n    const gridColors: { [key: string]: string } = {};\n\n    Object.entries(grid).filter(([key, val]) => !val).forEach(([key, val]) => {\n        gridColors[key] = GAP_COLOR;\n    });\n\n    units.forEach(unit => {\n        const isActivePlayerUnit = activePlayer.unitIds.includes(unit.stats.id);\n        const color = d3.cubehelix(unit.stats.color)!;\n        const headColor = d3.cubehelix(unit.stats.headColor)!;\n\n        if (!isActivePlayerUnit) {\n            color.s *= 0.2;\n            headColor.s *= 0.2;;\n            headColor.l *= 1.5;\n        }\n\n        unit.positions.forEach(position => {\n            gridColors[posHash(position)] = color.toString();\n        });\n        gridColors[posHash(head(unit))] = headColor.toString();\n    });\n    if (selectedUnit && phase === \"move\") {\n        const validMovePositions = bfs(selectedUnit, units, grid);\n        validMovePositions.forEach(position => {\n            gridColors[posHash(position)] = VALID_MOVE_POSITION_COLOR;\n        });\n    }\n    return gridColors;\n}\n\nconst initialGrid = rectGridConstructor(10, 10);\ninitialGrid[\"6-6\"] = false;\ninitialGrid[\"6-5\"] = false;\nconst initialUnits = defaultUnits.reduce((map: { [key: string]: Unit }, unit) => {\n    map[unit.stats.id] = unit;\n    return map;\n}, {});\nconst initialState: GameState = {\n    turn: 0,\n    phase: \"move\",\n    grid: initialGrid,\n    units: initialUnits,\n    selectedUnit: \"a\",\n    players: [\n        {\n            name: \"Jake\",\n            unitIds: [\"a\", \"b\"],\n        },\n        {\n            name: \"Cypress\",\n            unitIds: [\"c\"],\n        },\n    ],\n};\n\nexport const overlapsAnything = (units: Unit[], newPosition: Position) => {\n    for (const unit of units) {\n        if (overlaps(unit.positions, newPosition)) {\n            return true;\n        }\n    }\n    return false;\n}\n\nconst overlaps = (positions: Position[], position: Position) => {\n    for (const existingPosition of positions) {\n        if (existingPosition.x === position.x && existingPosition.y === position.y) {\n            return true;\n        }\n    }\n    return false;\n}\n\nconst locationValid = (grid: Grid, units: Unit[], unit: Unit, newPosition: Position) => {\n    const oldPositions = unit.positions;\n    const oldHead = oldPositions[oldPositions.length - 1];\n    return Math.abs(newPosition.x - oldHead.x) +\n        Math.abs(newPosition.y - oldHead.y) <= 1 &&\n        !overlapsAnything(units, newPosition) && inGrid(grid, newPosition);\n}\n\nexport const unitAt = (position: Position, units: Unit[]) => {\n    for (const unit of units) {\n        if (overlaps(unit.positions, position)) {\n            return unit;\n        }\n    }\n}\n\nexport const gameSlice = createSlice({\n    name: 'game',\n    initialState,\n    reducers: {\n        move: (state: GameState, action: PayloadAction<Position>) => {\n            if (state.phase !== \"move\" || state.selectedUnit === undefined) {\n                return;\n            }\n            const unit = state.units[state.selectedUnit];\n            if (unit.movesUsed >= unit.stats.movement) {\n                return;\n            }\n            const units = getUnitList(state);\n            if (locationValid(state.grid, units, unit, action.payload)) {\n                unit.positions.push(action.payload);\n                unit.movesUsed++;\n            }\n            if (unit.positions.length > unit.stats.maxLength) {\n                unit.positions.shift();\n            }\n        },\n        select: (state: GameState, action: PayloadAction<Position>) => {\n            const activeUnits = getActivePlayerUnits(state);\n            const selectedUnit = unitAt(action.payload, activeUnits);\n            if (selectedUnit) {\n                state.phase = \"move\";\n                state.selectedUnit = selectedUnit.stats.id;\n            }\n        },\n        reset: () => {\n            return initialState;\n        },\n        attack: (state: GameState, action: PayloadAction<Position>) => {\n            const targetPosition = action.payload;\n            const enemyUnits = getEnemyUnits(state);\n            const target = unitAt(targetPosition, enemyUnits);\n            if (state.phase !== \"attack\" || state.selectedUnit === undefined || !target) {\n                return;\n            }\n            const attacker = state.units[state.selectedUnit];\n            if (attacker === target || attacker.attackUsed || !isInRange(attacker, targetPosition)) {\n                return;\n            }\n            attacker.attackUsed = true;\n            if (attacker.stats.attack >= target.positions.length) {\n                delete state.units[target.stats.id];\n                deleteDeadPlayers(state);\n                if (state.players.length < 2) {\n                    state.winner = state.players[0].name;\n                    state.phase = \"game over\";\n                }\n            }\n            target.positions.splice(0, attacker.stats.attack);\n        },\n        endTurn: (state: GameState) => {\n            state.turn++;\n            for (const unit of getUnitList(state)) {\n                unit.movesUsed = 0;\n                unit.attackUsed = false;\n            };\n            state.selectedUnit = getActivePlayerUnits(state)[0].stats.id;\n        },\n        clickMove: (state: GameState) => {\n            const selectedUnit = getSelectedUnit(state);\n            if (selectedUnit && selectedUnit.movesUsed < selectedUnit.stats.movement) {\n                state.phase = \"move\";\n            }\n        },\n        clickAttack: (state: GameState) => {\n            const selectedUnit = getSelectedUnit(state);\n            if (selectedUnit && !selectedUnit.attackUsed) {\n                state.phase = \"attack\";\n            }\n        },\n    },\n});\n\nexport const { move, select, attack, reset, endTurn, clickMove, clickAttack } = gameSlice.actions;\n\n// Getters\nconst getUnitList = (state: GameState) => Object.values(state.units);\nconst getActivePlayerUnits = (state: GameState) => getUnitsForPlayer(state, getActivePlayer(state));\nconst getUnitsForPlayer = (state: GameState, player: Player) =>\n    player\n        .unitIds\n        .map(unitId => state.units[unitId])\n        .filter(unit => unit !== undefined);\nconst getActivePlayer = (state: GameState) => state.players[state.turn % state.players.length];\nconst getSelectedUnit = (state: GameState) => state.selectedUnit ? state.units[state.selectedUnit] : undefined;;\nconst getEnemyUnits = (state: GameState) => {\n    const activeUnitIds = getActivePlayer(state).unitIds;\n    const units = state.units;\n    const enemyUnits = Object.keys(units)\n        .filter(key => !activeUnitIds.includes(key))\n        .map(key => units[key]);\n    return enemyUnits;\n};\nconst deleteDeadPlayers = (state: GameState) => {\n    state.players = state.players.filter(player => getUnitsForPlayer(state, player).length > 0);\n}\n\n// Selectors\nexport const selectUnitList = (state: RootState) => getUnitList(state.game);\nexport const selectActivePlayerUnits = (state: RootState) => getActivePlayerUnits(state.game);\nexport const selectActivePlayer = (state: RootState) => getActivePlayer(state.game);\nexport const selectSelectedUnit = (state: RootState) => getSelectedUnit(state.game);\nexport const selectEnemyUnits = (state: RootState) => getEnemyUnits(state.game);\n\nexport const getGridGlows = createSelector(selectSelectedUnit, state => state.game.phase, selectUnitList, state => state.game.grid, generateGridGlows);\nexport const getGridColors = createSelector(selectSelectedUnit, state => state.game.phase, selectUnitList, state => state.game.grid, selectActivePlayer, generateGridColors);\n\nexport default gameSlice.reducer;\n","import { attack, move, select, unitAt, selectUnitList, Phase, selectActivePlayerUnits } from \"./gameSlice\";\nimport { useAppDispatch } from \"../../app/hooks\";\nimport { Position } from \"./Position\";\nimport { useSelector } from \"react-redux\";\nimport Unit from \"../unit/Unit\";\n\n\ntype Props = {\n    position: Position,\n    color?: string,\n    glowColor?: string,\n    phase: Phase,\n};\n\nconst isEmpty = (position: Position, units: Unit[]) => unitAt(position, units) === undefined;\n\nexport const GridCell = ({ position, color, glowColor, phase }: Props) => {\n    const dispatch = useAppDispatch();\n    const units = useSelector(selectUnitList);\n    const activePlayerUnits = useSelector(selectActivePlayerUnits);\n    const handleClick = () => {\n        const unit = unitAt(position, units);\n        if (unit && activePlayerUnits.includes(unit)) {\n            dispatch(select(position));\n        } else {\n            switch (phase) {\n                case \"move\":\n                    if (isEmpty(position, units)) {\n                        dispatch(move(position));\n                    }\n                    break;\n                case \"attack\":\n                    dispatch(attack(position));\n                    break;\n            };\n        }\n\n    };\n    const style = {\n        backgroundColor: color,\n        boxShadow: glowColor ? \"0px 0px 10px\" + glowColor : undefined,\n        transition: \"background-color 0.2s\",\n    };\n    return <div\n        style={style}\n        onClick={handleClick}\n    ></div>;\n}\n","import Unit from \"../unit/Unit\";\nimport styles from './Game.module.css';\n\nconst UnitInfo = ({ unit }: { unit: Unit }) =>\n    <div className={styles.unitInfo}>\n        <h2 style={{ color: unit.stats.headColor }}>{unit.stats.name}</h2>\n        <table>\n            <tbody>\n                <tr>\n                    <th>Movement range</th>\n                    <td>{unit.stats.movement}</td>\n                </tr>\n                <tr>\n                    <th>Attack range</th>\n                    <td>{unit.stats.range}</td>\n                </tr>\n                <tr>\n                    <th>Max Length</th>\n                    <td>{unit.stats.maxLength}</td>\n                </tr>\n                <tr>\n                    <th>Attack</th>\n                    <td>{unit.stats.attack}</td>\n                </tr>\n            </tbody>\n        </table >\n    </div>;\n\n\nexport default UnitInfo;","import React from \"react\";\nimport { useSelector } from \"react-redux\"\nimport { useAppDispatch } from \"../../app/hooks\";\nimport { RootState } from \"../../app/store\";\nimport styles from './Game.module.css';\nimport { endTurn, reset, selectSelectedUnit, getGridGlows, getGridColors, selectActivePlayer, Phase, clickAttack, clickMove } from \"./gameSlice\";\nimport { Grid, gridDimensions, positionOfGrid } from \"./Grid\";\nimport { GridCell } from \"./GridCell\";\nimport { posHash } from \"./Position\";\nimport UnitInfo from \"./UnitInfo\";\n\nconst genGrid = (\n    grid: Grid,\n    gridGlows: { [key: string]: string | undefined },\n    gridColors: { [key: string]: string | undefined },\n    phase: Phase,\n) => [...Array(gridDimensions(grid).height * gridDimensions(grid).width).keys()]\n    .map(i => {\n        const cellPos = positionOfGrid(i, grid);\n        const glowColor = gridGlows[posHash(cellPos)];\n        const color = gridColors[posHash(cellPos)];\n        return <GridCell\n            key={i}\n            color={color}\n            glowColor={glowColor}\n            position={cellPos}\n            phase={phase} />\n    });\n\nexport function Game() {\n    const dispatch = useAppDispatch();\n    const { grid, phase, selectedUnit, gridGlows, gridColors, activePlayer } =\n        useSelector((state: RootState) => ({\n            ...state.game,\n            selectedUnit: selectSelectedUnit(state),\n            gridGlows: getGridGlows(state),\n            gridColors: getGridColors(state),\n            activePlayer: selectActivePlayer(state),\n        }));\n    return (\n        <React.Fragment>\n            {\n                phase === \"game over\" &&\n                <h1>Game over, {activePlayer.name} wins!</h1>\n            }\n            {\n                phase !== \"game over\" &&\n                <h1>\n                    {activePlayer.name}:\n                    {\n                        phase === \"move\" &&\n                        <button\n                            onClick={() => dispatch(clickAttack())}\n                            className={styles.button}>Attack</button>\n                    }\n                    {\n                        phase === \"attack\" && selectedUnit &&\n                        <button\n                            onClick={() => dispatch(clickMove())}\n                            className={styles.button}\n                            disabled={selectedUnit.movesUsed === selectedUnit.stats.movement}>\n                            Move\n                        </button>\n                    }\n                    <button\n                        onClick={() => dispatch(endTurn())}\n                        className={styles.button}>End Turn</button>\n\n                </h1>\n            }\n\n\n            <div id={styles.mapAndInfo}>\n                <div className={styles.wrapper}>\n                    {genGrid(grid, gridGlows, gridColors, phase)}\n                </div>\n                {selectedUnit && <UnitInfo unit={selectedUnit} />}\n            </div>\n            <button onClick={() => dispatch(reset())}>reset</button>\n        </React.Fragment>\n    );\n}\n","import './App.css';\nimport { Game } from './features/game/Game';\n\nfunction App() {\n  return <Game />;\n}\n\nexport default App;\n","// A mock function to mimic making an async request for data\nexport function fetchCount(amount = 1) {\n  return new Promise<{ data: number }>((resolve) =>\n    setTimeout(() => resolve({ data: amount }), 500)\n  );\n}\n","import { createAsyncThunk, createSlice, PayloadAction } from '@reduxjs/toolkit';\nimport { RootState, AppThunk } from '../../app/store';\nimport { fetchCount } from './counterAPI';\n\nexport interface CounterState {\n  value: number;\n  status: 'idle' | 'loading' | 'failed';\n}\n\nconst initialState: CounterState = {\n  value: 0,\n  status: 'idle',\n};\n\n// The function below is called a thunk and allows us to perform async logic. It\n// can be dispatched like a regular action: `dispatch(incrementAsync(10))`. This\n// will call the thunk with the `dispatch` function as the first argument. Async\n// code can then be executed and other actions can be dispatched. Thunks are\n// typically used to make async requests.\nexport const incrementAsync = createAsyncThunk(\n  'counter/fetchCount',\n  async (amount: number) => {\n    const response = await fetchCount(amount);\n    // The value we return becomes the `fulfilled` action payload\n    return response.data;\n  }\n);\n\nexport const counterSlice = createSlice({\n  name: 'counter',\n  initialState,\n  // The `reducers` field lets us define reducers and generate associated actions\n  reducers: {\n    increment: (state) => {\n      // Redux Toolkit allows us to write \"mutating\" logic in reducers. It\n      // doesn't actually mutate the state because it uses the Immer library,\n      // which detects changes to a \"draft state\" and produces a brand new\n      // immutable state based off those changes\n      state.value += 1;\n    },\n    decrement: (state) => {\n      state.value -= 1;\n    },\n    // Use the PayloadAction type to declare the contents of `action.payload`\n    incrementByAmount: (state, action: PayloadAction<number>) => {\n      state.value += action.payload;\n    },\n  },\n  // The `extraReducers` field lets the slice handle actions defined elsewhere,\n  // including actions generated by createAsyncThunk or in other slices.\n  extraReducers: (builder) => {\n    builder\n      .addCase(incrementAsync.pending, (state) => {\n        state.status = 'loading';\n      })\n      .addCase(incrementAsync.fulfilled, (state, action) => {\n        state.status = 'idle';\n        state.value += action.payload;\n      });\n  },\n});\n\nexport const { increment, decrement, incrementByAmount } = counterSlice.actions;\n\n// The function below is called a selector and allows us to select a value from\n// the state. Selectors can also be defined inline where they're used instead of\n// in the slice file. For example: `useSelector((state: RootState) => state.counter.value)`\nexport const selectCount = (state: RootState) => state.counter.value;\n\n// We can also write thunks by hand, which may contain both sync and async logic.\n// Here's an example of conditionally dispatching actions based on current state.\nexport const incrementIfOdd = (amount: number): AppThunk => (\n  dispatch,\n  getState\n) => {\n  const currentValue = selectCount(getState());\n  if (currentValue % 2 === 1) {\n    dispatch(incrementByAmount(amount));\n  }\n};\n\nexport default counterSlice.reducer;\n","import { configureStore, ThunkAction, Action } from '@reduxjs/toolkit';\nimport counterReducer from '../features/counter/counterSlice';\nimport gameReducer from '../features/game/gameSlice';\n\nexport const store = configureStore({\n  reducer: {\n    counter: counterReducer,\n    game: gameReducer,\n  },\n});\n\nexport type AppDispatch = typeof store.dispatch;\nexport type RootState = ReturnType<typeof store.getState>;\nexport type AppThunk<ReturnType = void> = ThunkAction<\n  ReturnType,\n  RootState,\n  unknown,\n  Action<string>\n>;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then((registration) => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch((error) => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' },\n  })\n    .then((response) => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then((registration) => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then((registration) => {\n        registration.unregister();\n      })\n      .catch((error) => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport { store } from './app/store';\nimport { Provider } from 'react-redux';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(\n  <React.StrictMode>\n    <Provider store={store}>\n      <App />\n    </Provider>\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}